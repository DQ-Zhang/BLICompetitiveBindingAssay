###############################################
#                Dingqi Zhang                 #
#             School of Pharmacy              #
#  Macau University of Science and Technology #
#               December, 2020                #
###############################################
import pandas as pd
import numpy as np
import statistics as st
import os
import time

curdir = os.path.dirname(os.path.realpath(__file__))
os.chdir(curdir)

def readcycle(subdf, association):
    """
    extracts mean and standard deviation of the signal at steady state.
    params:
    subdf       ->  a pandas dataframe with two coloums, time(s) and response size(nm) of the association & dissociation steps. pandas dataframe
    association ->  time(s) of the association step. int
    output. tuple
    """
    subdf.columns = ["Time", "Response"]
    start_time = float(subdf.iat[0, 0])
    steady_state = subdf.loc[(subdf["Time"]>start_time+association-5) & (subdf["Time"]<start_time+association), "Response"]
    response_mean = st.mean(steady_state)
    response_sd = st.stdev(steady_state)
    return (response_mean,response_sd)

def readrow(filename, first, seconds, x_association, y_association, z_association):
    """
    extracts mean and standard deviation of the signal at steady state for every cycle of a probe.
    params:
    filename      ->  raw data file for a probe, generated by Octet Analysis software. str
    first         ->  the first compound for this probe. str
    x_association ->  time(s) of the association step for detecting signal of the first compound alone. int
    y_association ->  time(s) of the association step for detecting signal of the second compound alone. int
    z_association ->  time(s) of the association step for detecting signal of the mixture. int
    output. tuple
    """
    df = pd.read_table(filename,skiprows=range(0,5))
    
    cycles_num = int(df.shape[1]/3)

    if 3*len(seconds) != cycles_num:
        print("number of interactions:\t"+str(len(seconds)))
        print("raw data Excel file cycles number:\t"+str(cycles_num))
        raise Exception("number of cycles incorrect!")

    counter = 0
    for interaction in seconds:
        y_df = df.iloc[:,[9*counter, 9*counter+1]]
        x_df = df.iloc[:,[9*counter+3, 9*counter+4]]
        z_df = df.iloc[:,[9*counter+6, 9*counter+7]]
        counter += 1
        x_signal = readcycle(x_df, x_association)
        y_signal = readcycle(y_df, y_association)
        z_signal = readcycle(z_df, z_association)
        yield first, interaction, x_signal, y_signal, z_signal

def readfirsts(filename):
    """
    mapping probes (A-H) to first compounds.
    params:
    filename   ->  path to layout file. str
    output. dict
    """
    df = pd.read_excel(filename,dtype=str,index_col=0).dropna()
    return df.iloc[:,0].to_dict()


def readlayout(filename):
    """
    reading first compounds and second compounds for every probe.
    params:
    filename   ->  path to layout file. str
    generator. dict
    """
    df = pd.read_excel(filename,dtype=str,index_col=0).dropna()

    for row in df.itertuples(False,name=None):
        yield {row[0]:row[1:]}



def readdata(layout, rawfolder, x_association, y_association, z_association):
    """
    reading raw data files
    params:
    layout        ->  path to layout file. str
    rawfolder     ->  path to folder containing the raw files. str
    x_association ->  time(s) of the association step for detecting signal of the first compound alone. int
    y_association ->  time(s) of the association step for detecting signal of the second compound alone. int
    z_association ->  time(s) of the association step for detecting signal of the mixture. int
    generator. list
    """
    rows = os.listdir(rawfolder)

    firsts_mapping = readfirsts(layout)
    #print(firsts_mapping)
    matrix = readlayout(layout)

    if len(firsts_mapping) != len(rows):
        raise Exception("number of first compounds does not equal number of files in raw file folder!")

    for row in rows:
        first = firsts_mapping[row[0]]
        seconds = next(matrix)[first]
        raw_results = list(readrow(rawfolder+"\\"+row, first, seconds, x_association, y_association, z_association))
        yield raw_results

def detect_binding(mean,sd):
    """
    binding is detected when mean > 10 X sd (limit of quantification) of the signal.
    params:
    mean       ->  mean of the signal. float
    sd         ->  standard deviation of the signal. float
    filename   ->  path to layout file. str
    output. str
    """
    if abs(mean)>10*sd:
        return "yes"
    else:
        return "no"

def test_validity(first_binding,second_binding):
    """
    a test is valid when both first and second compound are detected.
    params:
    first_binding   ->  whether the first compound if detected. str
    second_binding  ->  whether the second compound if detected. str
    output. str
    """
    if first_binding == "yes" and second_binding == "yes":
        return "yes"
    else:
        return "no"

def calculate_competition(y,z):
    """
    calculates the level of competition based on ratio between the means of signals of the second compound, alone or with probe pre-occupied.
    params:
    y   ->  mean of the signal of the second compound alone. float
    z   ->  mean of the signal of the mixture. float
    output. str
    """
    if z>=0.6*y:
        return "non-competition"
    elif z>0.2*y and z<0.6*y:
        return "weak competition"
    else:
        return "competition"

def writexls(first, second, x_signal, y_signal, z_signal, date, time):
    """
    generates an xls file that contains the result of one interaction.
    params:
    y   ->  mean of the signal of the second compound alone. float
    z   ->  mean of the signal of the mixture. float
    output. str
    """
    test_name ="{}_{}".format(date,time.replace(":","-"))
    os.makedirs("Data\\{}".format(test_name), exist_ok=True)
    first_binding = detect_binding(x_signal[0],x_signal[1])
    second_binding = detect_binding(y_signal[0],y_signal[1])
    validity = test_validity(first_binding,second_binding)
    if validity == "yes":
        competition = calculate_competition(y_signal[0],z_signal[0])
    else:
        competition = "invalid"
    
    with open("data\\{}\\{}_vs_{}_{}_{}.xls".format(test_name, first, second, competition, test_name), "w", encoding="utf-8") as xls:
        xls.write("first compound\t{}\n".format(first))
        xls.write("second compound\t{}\n".format(second))
        xls.write("Copy the following and paste on the result table\n")
        xls.write("Entry Date\t{}\tEntry Time\t{}\n".format(date, time))
        xls.write("x\t{}\tx sd\t{}\n".format(x_signal[0],x_signal[1]))
        xls.write("y\t{}\ty sd\t{}\n".format(y_signal[0],y_signal[1]))
        xls.write("z\t{}\tz sd\t{}\n".format(z_signal[0],z_signal[1]))
        xls.write("first binding\t{}\ttest validity\t{}\n".format(first_binding,validity))
        xls.write("second binding\t{}\tcompetition\t{}\n".format(second_binding,competition))
    
    return validity, competition

def main(layout, rawfolder, x_association, y_association, z_association):
    """
    Main function. Extracts results from raw data files and gerates reports.
    params:
    layout        ->  path to layout file. str
    rawfolder     ->  path to folder containing the raw files. str
    x_association ->  time(s) of the association step for detecting signal of the first compound alone. int
    y_association ->  time(s) of the association step for detecting signal of the second compound alone. int
    z_association ->  time(s) of the association step for detecting signal of the mixture. int
    output. str
    """
    parsed_results = list(readdata(layout, rawfolder, x_association, y_association, z_association))
    entry_date = time.strftime("%Y-%m-%d", time.localtime())
    entry_time = time.strftime("%H:%M:%S", time.localtime())

    valids = 0
    competitions = 0
    weak_competitions = 0
    no_competitions = 0
    invalids = 0

    for first in parsed_results:
        for interaction in first:
            test_result = writexls(interaction[0], interaction[1], interaction[2], interaction[3], interaction[4], entry_date, entry_time)

            if test_result[0] == "yes":
                valids += 1
            
            if test_result[1] == "competition":
                competitions += 1
            elif test_result[1] == "weak competition":
                weak_competitions +=1
            elif test_result[1] == "non-competition":
                no_competitions += 1
            else:
                invalids += 1
    
    print("\n\n")
    print("RESULT BRIEFING")
    print("============================")
    print("Total number of interactions\t{}".format(competitions+no_competitions+weak_competitions+invalids))
    print("============================")
    print("Number of valid tests\t\t{}".format(valids))
    print("============================")
    print("Number of non-competitions\t{}".format(no_competitions))
    print("Number of weak competitions\t{}".format(weak_competitions))
    print("Number of competitions\t\t{}".format(competitions))
    print("============================")
    print("Number of invalid tests\t\t{}".format(invalids))
    print("============================")


if __name__ == "__main__":
    main("plate_layout\\layout.xlsx", "raw_data", 300, 300, 300)


        